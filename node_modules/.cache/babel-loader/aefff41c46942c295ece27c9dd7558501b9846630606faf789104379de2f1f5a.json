{"ast":null,"code":"function t() {\n  return t = Object.assign ? Object.assign.bind() : function (t) {\n    for (var i = 1; i < arguments.length; i++) {\n      var e = arguments[i];\n      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, t.apply(this, arguments);\n}\nfunction i(t, i, e) {\n  return Math.max(t, Math.min(i, e));\n}\nclass e {\n  advance(t) {\n    var e;\n    if (!this.isRunning) return;\n    let s = !1;\n    if (this.lerp) this.value = (o = this.value, n = this.to, (1 - (r = 1 - Math.exp(-60 * this.lerp * t))) * o + r * n), Math.round(this.value) === this.to && (this.value = this.to, s = !0);else {\n      this.currentTime += t;\n      const e = i(0, this.currentTime / this.duration, 1);\n      s = e >= 1;\n      const o = s ? 1 : this.easing(e);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var o, n, r;\n    null == (e = this.onUpdate) || e.call(this, this.value, {\n      completed: s\n    }), s && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, i, {\n    lerp: e = .1,\n    duration: s = 1,\n    easing: o = t => t,\n    onUpdate: n\n  }) {\n    this.from = this.value = t, this.to = i, this.lerp = e, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, this.onUpdate = n;\n  }\n}\nclass s {\n  constructor({\n    wrapper: t,\n    content: i,\n    autoResize: e = !0\n  } = {}) {\n    if (this.resize = () => {\n      this.onWrapperResize(), this.onContentResize();\n    }, this.onWrapperResize = () => {\n      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n    }, this.onContentResize = () => {\n      this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n    }, this.wrapper = t, this.content = i, e) {\n      const t = function (t, i) {\n        let e;\n        return function () {\n          let i = arguments,\n            s = this;\n          clearTimeout(e), e = setTimeout(function () {\n            t.apply(s, i);\n          }, 250);\n        };\n      }(this.resize);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var t, i;\n    null == (t = this.wrapperResizeObserver) || t.disconnect(), null == (i = this.contentResizeObserver) || i.disconnect();\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass o {\n  constructor() {\n    this.events = {};\n  }\n  emit(t, ...i) {\n    let e = this.events[t] || [];\n    for (let t = 0, s = e.length; t < s; t++) e[t](...i);\n  }\n  on(t, i) {\n    var e;\n    return (null == (e = this.events[t]) ? void 0 : e.push(i)) || (this.events[t] = [i]), () => {\n      var e;\n      this.events[t] = null == (e = this.events[t]) ? void 0 : e.filter(t => i !== t);\n    };\n  }\n  off(t, i) {\n    var e;\n    this.events[t] = null == (e = this.events[t]) ? void 0 : e.filter(t => i !== t);\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass n {\n  constructor(t, {\n    wheelMultiplier: e = 1,\n    touchMultiplier: s = 2,\n    normalizeWheel: n = !1\n  }) {\n    this.onTouchStart = t => {\n      const {\n        clientX: i,\n        clientY: e\n      } = t.targetTouches ? t.targetTouches[0] : t;\n      this.touchStart.x = i, this.touchStart.y = e, this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n    }, this.onTouchMove = t => {\n      const {\n          clientX: i,\n          clientY: e\n        } = t.targetTouches ? t.targetTouches[0] : t,\n        s = -(i - this.touchStart.x) * this.touchMultiplier,\n        o = -(e - this.touchStart.y) * this.touchMultiplier;\n      this.touchStart.x = i, this.touchStart.y = e, this.lastDelta = {\n        x: s,\n        y: o\n      }, this.emitter.emit(\"scroll\", {\n        deltaX: s,\n        deltaY: o,\n        event: t\n      });\n    }, this.onTouchEnd = t => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event: t\n      });\n    }, this.onWheel = t => {\n      let {\n        deltaX: e,\n        deltaY: s\n      } = t;\n      this.normalizeWheel && (e = i(-100, e, 100), s = i(-100, s, 100)), e *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n        deltaX: e,\n        deltaY: s,\n        event: t\n      });\n    }, this.element = t, this.wheelMultiplier = e, this.touchMultiplier = s, this.normalizeWheel = n, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new o(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, i) {\n    return this.emitter.on(t, i);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n}\nclass r {\n  constructor({\n    wrapper: i = window,\n    content: r = document.documentElement,\n    wheelEventsTarget: l = i,\n    smoothWheel: h = !0,\n    smoothTouch: a = !1,\n    syncTouch: c = !1,\n    syncTouchLerp: u = .1,\n    __iosNoInertiaSyncTouchLerp: p = .4,\n    touchInertiaMultiplier: m = 35,\n    duration: d,\n    easing: v = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: g = d && .1,\n    infinite: S = !1,\n    orientation: w = \"vertical\",\n    gestureOrientation: f = \"vertical\",\n    touchMultiplier: y = 1,\n    wheelMultiplier: T = 1,\n    normalizeWheel: z = !1,\n    autoResize: M = !0\n  } = {}) {\n    this.onVirtualScroll = ({\n      deltaX: i,\n      deltaY: e,\n      event: s\n    }) => {\n      if (s.ctrlKey) return;\n      const o = s.type.includes(\"touch\"),\n        n = s.type.includes(\"wheel\");\n      if (\"vertical\" === this.options.gestureOrientation && 0 === e || \"horizontal\" === this.options.gestureOrientation && 0 === i || o && \"vertical\" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && e <= 0) return;\n      let r = s.composedPath();\n      if (r = r.slice(0, r.indexOf(this.rootElement)), r.find(t => {\n        var i;\n        return (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent\")) || o && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-touch\")) || n && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-wheel\")) || (null == (i = t.classList) ? void 0 : i.contains(\"lenis\"));\n      })) return;\n      if (this.isStopped || this.isLocked) return void s.preventDefault();\n      if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && o || this.options.smoothWheel && n, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n      s.preventDefault();\n      let l = e;\n      \"both\" === this.options.gestureOrientation ? l = Math.abs(e) > Math.abs(i) ? e : i : \"horizontal\" === this.options.gestureOrientation && (l = i);\n      const h = o && this.options.syncTouch,\n        a = o && \"touchend\" === s.type && Math.abs(l) > 1;\n      a && (l = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + l, t({\n        programmatic: !1\n      }, h && {\n        lerp: a ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp\n      }));\n    }, this.onScroll = () => {\n      if (!this.isScrolling) {\n        const t = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n      }\n    }, window.lenisVersion = \"1.0.22\", i !== document.documentElement && i !== document.body || (i = window), this.options = {\n      wrapper: i,\n      content: r,\n      wheelEventsTarget: l,\n      smoothWheel: h,\n      smoothTouch: a,\n      syncTouch: c,\n      syncTouchLerp: u,\n      __iosNoInertiaSyncTouchLerp: p,\n      touchInertiaMultiplier: m,\n      duration: d,\n      easing: v,\n      lerp: g,\n      infinite: S,\n      gestureOrientation: f,\n      orientation: w,\n      touchMultiplier: y,\n      wheelMultiplier: T,\n      normalizeWheel: z,\n      autoResize: M\n    }, this.dimensions = new s({\n      wrapper: i,\n      content: r,\n      autoResize: M\n    }), this.rootElement.classList.add(\"lenis\"), this.velocity = 0, this.isStopped = !1, this.isSmooth = h || a, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.animate = new e(), this.emitter = new o(), this.options.wrapper.addEventListener(\"scroll\", this.onScroll, {\n      passive: !1\n    }), this.virtualScroll = new n(l, {\n      touchMultiplier: y,\n      wheelMultiplier: T,\n      normalizeWheel: z\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.rootElement.classList.remove(\"lenis\"), this.rootElement.classList.remove(\"lenis-smooth\"), this.rootElement.classList.remove(\"lenis-scrolling\"), this.rootElement.classList.remove(\"lenis-stopped\");\n  }\n  on(t, i) {\n    return this.emitter.on(t, i);\n  }\n  off(t, i) {\n    return this.emitter.off(t, i);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const i = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * i);\n  }\n  scrollTo(t, {\n    offset: e = 0,\n    immediate: s = !1,\n    lock: o = !1,\n    duration: n = this.options.duration,\n    easing: r = this.options.easing,\n    lerp: l = !n && this.options.lerp,\n    onComplete: h = null,\n    force: a = !1,\n    programmatic: c = !0\n  } = {}) {\n    if (!this.isStopped || a) {\n      if ([\"top\", \"left\", \"start\"].includes(t)) t = 0;else if ([\"bottom\", \"right\", \"end\"].includes(t)) t = this.limit;else {\n        var u;\n        let i;\n        if (\"string\" == typeof t ? i = document.querySelector(t) : null != (u = t) && u.nodeType && (i = t), i) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            e -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = i.getBoundingClientRect();\n          t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof t) {\n        if (t += e, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = i(0, t, this.limit), s) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.emit(), void (null == h || h());\n        if (!c) {\n          if (t === this.targetScroll) return;\n          this.targetScroll = t;\n        }\n        this.animate.fromTo(this.animatedScroll, t, {\n          duration: n,\n          easing: r,\n          lerp: l,\n          onUpdate: (t, {\n            completed: i\n          }) => {\n            o && (this.isLocked = !0), this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), i && (o && (this.isLocked = !1), requestAnimationFrame(() => {\n              this.isScrolling = !1;\n            }), this.velocity = 0, null == h || h()), this.emit();\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? this.options.content : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;\n    var t;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.rootElement.classList.toggle(\"lenis-smooth\", t), this.__isSmooth = t);\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.rootElement.classList.toggle(\"lenis-scrolling\", t), this.__isScrolling = t);\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.rootElement.classList.toggle(\"lenis-stopped\", t), this.__isStopped = t);\n  }\n}\nexport { r as default };","map":{"version":3,"names":["i","t","e","Math","max","min","advance","isRunning","s","lerp","value","o","n","to","r","exp","round","currentTime","duration","easing","from","onUpdate","call","completed","stop","fromTo","constructor","wrapper","content","autoResize","resize","onWrapperResize","onContentResize","window","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","arguments","clearTimeout","setTimeout","apply","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","limit","x","y","events","emit","length","on","push","filter","off","wheelMultiplier","touchMultiplier","normalizeWheel","onTouchStart","clientX","clientY","targetTouches","touchStart","lastDelta","onTouchMove","emitter","deltaX","deltaY","event","onTouchEnd","onWheel","element","addEventListener","passive","removeEventListener","document","documentElement","wheelEventsTarget","l","smoothWheel","h","smoothTouch","a","syncTouch","c","syncTouchLerp","u","__iosNoInertiaSyncTouchLerp","p","touchInertiaMultiplier","m","d","v","pow","g","infinite","S","orientation","w","gestureOrientation","f","T","z","M","onVirtualScroll","ctrlKey","type","includes","options","scroll","composedPath","slice","indexOf","rootElement","find","hasAttribute","classList","contains","isStopped","isLocked","preventDefault","isSmooth","isScrolling","animate","abs","velocity","scrollTo","targetScroll","programmatic","onScroll","animatedScroll","actualScroll","direction","sign","lenisVersion","body","dimensions","add","virtualScroll","remove","setScroll","isHorizontal","scrollLeft","scrollTop","reset","start","raf","time","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","requestAnimationFrame","progress","__isSmooth","toggle","__isScrolling","__isStopped","default"],"sources":["D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\maths.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\animate.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\dimensions.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\debounce.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\emitter.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\virtual-scroll.js","D:\\Work\\CV-page\\cv-page\\node_modules\\@studio-freight\\lenis\\src\\index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, { completed })\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(from, to, { lerp = 0.1, duration = 1, easing = (t) => t, onUpdate }) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\nexport class Dimensions {\r\n  constructor({ wrapper, content, autoResize = true } = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      const resize = debounce(this.resize, 250)\r\n\r\n      if (this.wrapper !== window) {\r\n        this.wrapperResizeObserver = new ResizeObserver(resize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(resize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    this.scrollHeight = this.content.scrollHeight\r\n    this.scrollWidth = this.content.scrollWidth\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event, ...args) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event, cb) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  off(event, callback) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport { clamp } from './maths'\r\n\r\nexport class VirtualScroll {\r\n  constructor(\r\n    element,\r\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n    this.normalizeWheel = normalizeWheel\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\r\n    this.element.addEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event) => {\r\n    let { deltaX, deltaY } = event\r\n\r\n    if (this.normalizeWheel) {\r\n      deltaX = clamp(-100, deltaX, 100)\r\n      deltaY = clamp(-100, deltaY, 100)\r\n    }\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n}\r\n","import { version } from '../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\nexport default class Lenis {\r\n  // isScrolling = true when scroll is animating\r\n  // isStopped = true if user should not be able to scroll - enable/disable programmatically\r\n  // isSmooth = true if scroll should be animated\r\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\r\n\r\n  /**\r\n   * @typedef {(t: number) => number} EasingFunction\r\n   * @typedef {'vertical' | 'horizontal'} Orientation\r\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\r\n   *\r\n   * @typedef LenisOptions\r\n   * @property {Window | HTMLElement} [wrapper]\r\n   * @property {HTMLElement} [content]\r\n   * @property {Window | HTMLElement} [wheelEventsTarget]\r\n   * @property {boolean} [smoothWheel]\r\n   * @property {boolean} [smoothTouch]\r\n   * @property {boolean} [syncTouch]\r\n   * @property {number} [syncTouchLerp]\r\n   * @property {number} [touchInertiaMultiplier]\r\n   * @property {number} [duration]\r\n   * @property {EasingFunction} [easing]\r\n   * @property {number} [lerp]\r\n   * @property {boolean} [infinite]\r\n   * @property {Orientation} [orientation]\r\n   * @property {GestureOrientation} [gestureOrientation]\r\n   * @property {number} [touchMultiplier]\r\n   * @property {number} [wheelMultiplier]\r\n   * @property {boolean} [normalizeWheel]\r\n   * @property {boolean} [autoResize]\r\n   *\r\n   * @param {LenisOptions}\r\n   */\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper,\r\n    smoothWheel = true,\r\n    smoothTouch = false,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.1,\r\n    __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = duration && 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    normalizeWheel = false,\r\n    autoResize = true,\r\n  } = {}) {\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (wrapper === document.documentElement || wrapper === document.body) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      smoothWheel,\r\n      smoothTouch,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      __iosNoInertiaSyncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n      autoResize,\r\n    }\r\n\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    this.rootElement.classList.add('lenis')\r\n\r\n    this.velocity = 0\r\n    this.isStopped = false\r\n    this.isSmooth = smoothWheel || smoothTouch\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll = new VirtualScroll(wheelEventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener('scroll', this.onScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.rootElement.classList.remove('lenis')\r\n    this.rootElement.classList.remove('lenis-smooth')\r\n    this.rootElement.classList.remove('lenis-scrolling')\r\n    this.rootElement.classList.remove('lenis-stopped')\r\n  }\r\n\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event, callback) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  setScroll(scroll) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  onVirtualScroll = ({ deltaX, deltaY, event }) => {\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    if (\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) || // trackpad previous/next page gesture\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0) ||\r\n      (isTouch &&\r\n        this.options.gestureOrientation === 'vertical' &&\r\n        this.scroll === 0 &&\r\n        !this.options.infinite &&\r\n        deltaY <= 0) // touch pull to refresh\r\n    )\r\n      return\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node.hasAttribute?.('data-lenis-prevent') ||\r\n          (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n          (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n          node.classList?.contains('lenis') // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault()\r\n      return\r\n    }\r\n\r\n    this.isSmooth =\r\n      ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!this.isSmooth) {\r\n      this.isScrolling = false\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 1\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch && {\r\n        lerp: hasTouchInertia\r\n          ? this.syncTouchLerp\r\n          : this.options.__iosNoInertiaSyncTouchLerp,\r\n      }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  onScroll = () => {\r\n    if (!this.isScrolling) {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.velocity = 0\r\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\r\n      this.emit()\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = !duration && this.options.lerp,\r\n      onComplete = null,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n    } = {}\r\n  ) {\r\n    if (this.isStopped && !force) return\r\n\r\n    // keywords\r\n    if (['top', 'left', 'start'].includes(target)) {\r\n      target = 0\r\n    } else if (['bottom', 'right', 'end'].includes(target)) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      this.emit()\r\n      onComplete?.()\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      if (target === this.targetScroll) return\r\n\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onUpdate: (value, { completed }) => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = true\r\n\r\n        // updated\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity)\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        // completed\r\n        if (completed) {\r\n          if (lock) this.isLocked = false\r\n          requestAnimationFrame(() => {\r\n            //avoid double scroll event\r\n            this.isScrolling = false\r\n          })\r\n          this.velocity = 0\r\n          onComplete?.()\r\n        }\r\n\r\n        this.emit()\r\n      },\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return this.options.wrapper === window\r\n      ? this.options.content\r\n      : this.options.wrapper\r\n  }\r\n\r\n  get limit() {\r\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll() {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll() {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress() {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.__isSmooth\r\n  }\r\n\r\n  set isSmooth(value) {\r\n    if (this.__isSmooth !== value) {\r\n      this.rootElement.classList.toggle('lenis-smooth', value)\r\n      this.__isSmooth = value\r\n    }\r\n  }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  set isScrolling(value) {\r\n    if (this.__isScrolling !== value) {\r\n      this.rootElement.classList.toggle('lenis-scrolling', value)\r\n      this.__isScrolling = value\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  set isStopped(value) {\r\n    if (this.__isStopped !== value) {\r\n      this.rootElement.classList.toggle('lenis-stopped', value)\r\n      this.__isStopped = value\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}